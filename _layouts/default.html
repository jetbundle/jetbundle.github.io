<!DOCTYPE html>
<html>
  {% include head.html %}
  <body class="animated fadeIn">
    {% include header.html %}
    <div class="container">
      <div id="background-div">
        <svg id="background-svg">
          <lineargradient id="Gradient1" x1="0" x2="0" y1="0" y2="1">
            <stop stop-opacity="0" class="bgColor1" offset="0%" />
            <stop stop-opacity="1" class="bgColor2" offset="100%" />
          </lineargradient>
        </svg>
      </div>
      {{ content }}
    </div>
    {% include footer.html %}
    
    <!-- JetBundle Gauge Theme JavaScript - Minimal and Optimized -->
    <script>
      // Minimal style enforcement - CSS handles most styling
      (function() {
        'use strict';
        
        // Wait for page to be interactive
        if (document.readyState === 'loading') {
          document.addEventListener('DOMContentLoaded', applyStyles);
        } else {
          // Use setTimeout to ensure this runs after deferred scripts
          setTimeout(applyStyles, 100);
        }
        
        function applyStyles() {
          try {
            // Only apply styles that CSS can't handle (SVG gradients)
            const svg = document.getElementById('background-svg');
            if (svg) {
              const stops = svg.querySelectorAll('stop:not([data-gauge-theme])');
              stops.forEach(stop => {
                stop.setAttribute('data-gauge-theme', 'applied');
                if (stop.classList.contains('bgColor1')) {
                  stop.setAttribute('stop-color', '#0b0e17');
                } else if (stop.classList.contains('bgColor2')) {
                  stop.setAttribute('stop-color', '#0a0d14');
                }
              });
            }
          } catch (e) {
            // Silently fail - CSS handles styling
          }
        }
        
        // Lightweight cursor trail - only if user moves mouse
        let trailInit = false;
        let trailActive = false;
        const trailLength = 8; // Reduced for performance
        let container = null;
        let animFrame = null;
        let mx = 0, my = 0;
        let lastMove = 0;
        const trail = [];
        
        function initTrail() {
          if (trailInit) return;
          trailInit = true;
          
          container = document.createElement('div');
          container.id = 'mouse-trail-container';
          container.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:99999;';
          document.body.appendChild(container);
          
          for (let i = 0; i < trailLength; i++) {
            const p = document.createElement('div');
            const size = Math.max(2, 4 - i * 0.15);
            const opacity = Math.max(0, 0.8 - i * 0.1);
            p.style.cssText = `position:absolute;width:${size}px;height:${size}px;background:radial-gradient(circle,rgba(255,107,53,${opacity})0%,rgba(14,165,233,${opacity*0.8})50%,transparent 100%);border-radius:50%;pointer-events:none;opacity:0;will-change:transform,opacity;transition:opacity 0.1s;`;
            container.appendChild(p);
            trail.push({el:p,x:0,y:0,op:0});
          }
        }
        
        function startTrail() {
          if (trailActive || !trailInit) return;
          trailActive = true;
          lastMove = Date.now();
          
          function animate() {
            if (!trailActive) {
              animFrame = null;
              return;
            }
            
            const now = Date.now();
            if (now - lastMove > 1000) {
              // Fade out after 1s inactivity
              let allInvisible = true;
              trail.forEach(p => {
                p.op = Math.max(0, p.op - 0.3);
                p.el.style.opacity = p.op;
                p.el.style.transform = `translate(${p.x}px,${p.y}px)`;
                if (p.op > 0.01) allInvisible = false;
              });
              if (allInvisible) {
                trailActive = false;
                animFrame = null;
                return;
              }
            } else {
              trail.forEach((p,i)=>{
                if(i===0){
                  p.x=mx;
                  p.y=my;
                  p.op=1;
                } else{
                  const prev=trail[i-1];
                  const dx=prev.x-p.x;
                  const dy=prev.y-p.y;
                  const dist=Math.sqrt(dx*dx+dy*dy);
                  if(dist>2){
                    p.x+=dx*0.25;
                    p.y+=dy*0.25;
                  } else {
                    p.x=prev.x;
                    p.y=prev.y;
                  }
                  p.op=Math.max(0,p.op-0.08);
                }
                p.el.style.transform = `translate(${p.x}px,${p.y}px)`;
                p.el.style.opacity = p.op;
              });
            }
            animFrame = requestAnimationFrame(animate);
          }
          animFrame = requestAnimationFrame(animate);
        }
        
        // Lazy load trail only on mouse move
        document.addEventListener('mousemove', function(e) {
          mx = e.clientX;
          my = e.clientY;
          lastMove = Date.now();
          if (!trailInit) {
            // Delay initialization to avoid blocking
            requestIdleCallback ? requestIdleCallback(initTrail) : setTimeout(initTrail, 200);
          }
          if (trailInit && !trailActive) {
            startTrail();
          }
        }, { passive: true });
      })();
    </script>
  </body>
</html>
