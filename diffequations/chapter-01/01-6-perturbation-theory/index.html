<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Section 1.6: Classical Perturbation Theory</title>
    <meta name="description"
        content="We expand around what we can solve — but secular terms destroy validity over long times, and boundary layers reveal the fragility of uniform convergence.">

    <!-- KaTeX – canonical loading -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {delimiters: [{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false}], throwOnError:false});">
        </script>

    <link rel="stylesheet" href="/diffequations/styles.css">
    <script src="/diffequations/navigation-data.js"></script>
    <script src="/diffequations/navigation.js"></script>
    <!-- Manifold background only on main index -->
</head>

<body>
    <main>
        <!-- 1. HOOK -->
        <header class="hook">
            <h1>Section 1.6: Classical Perturbation Theory</h1>
            <p class="hook-text">
                We attempt to solve nonlinear problems by expanding around a linear limit: perturbation theory trades exact solvability for approximate validity.
            </p>
            <p class="hook-subtitle">
                But secular terms destroy validity over long times, and boundary layers reveal that uniform convergence is a fragile dream.
            </p>
        </header>

        <!-- 2. DESCRIPTION -->
        <p class="description">
            Regular and singular perturbation, Poincaré-Lindstedt method, multiple scales, and the boundary layers that force us toward matched asymptotic expansions.
        </p>

        <article>

            <!-- 3. NARRATIVE INTRODUCTION (3 paragraphs) -->
            <section class="narrative-intro">
                <p>We attempt to solve nonlinear problems by expanding around a linear limit. Regular perturbation assumes $y(x;\epsilon) \sim \sum_{n=0}^{\infty} \epsilon^n y_n(x)$, substituting into the equation and solving order by order. For finite time intervals and small $\epsilon$, this works beautifully. The unperturbed solution $y_0$ solves the linear problem, and each correction $y_n$ solves a linear inhomogeneous equation driven by lower-order terms. The method is systematic, elegant, and powerful.</p>
                <p>But this power is deceptive. Secular terms—like $t \sin t$ that grow unbounded—appear in the perturbation series, destroying validity as $t \to \infty$. The Poincaré–Lindstedt method rescales time to remove these resonances, revealing that nonlinearity shifts frequencies. Multiple scales analysis introduces slow times $t_1 = \epsilon t$ to capture envelope evolution, showing that amplitude and phase evolve separately from rapid oscillations. These techniques work, but they reveal that perturbation theory is fundamentally a short-time tool.</p>
                <p>The crisis deepens with singular perturbations. When $\epsilon$ multiplies the highest derivative, setting $\epsilon = 0$ reduces the order and loses boundary conditions. The solution adjusts rapidly in boundary layers of thickness $\delta(\epsilon)$, creating structures that defy uniform convergence. Matched asymptotic expansions build separate solutions in inner and outer regions, matching them in an overlap zone. This works, but it reveals that the classical notion of a solution—smooth, uniformly valid—is too narrow. We need a framework that can handle rapid transitions, multiscale dynamics, and the breakdown of uniform convergence.</p>
            </section>

            <!-- CORE CONTENT WITH SEMANTIC BLOCKS & INTERMEDIATE CLIFFHANGERS -->

            <section>
                <h2>Regular Perturbation</h2>

                <div class="definition">
                    <p><strong>Regular Perturbation:</strong> For $y'=f(x,y,\epsilon)$ with $y(0)=\alpha$, assume</p>
                    $$y(x;\epsilon)\sim \sum_{n=0}^{\infty}\epsilon^{n}y_{n}(x).$$
                    <p>Substituting and expanding $f$ about $\epsilon=0$ yields the unperturbed system $y_{0}'=f(x,y_{0},0)$ followed by linear inhomogeneous equations for $y_{n}$ driven by $y_{0},\dots,y_{n-1}$. Analyticity of $f$ in $y$ and $\epsilon$ guarantees convergence for $\vert \epsilon \vert <R$ on finite intervals.</p>
                </div>

                <div class="example">
                    <p><strong>Regular Perturbation of a Linear ODE</strong></p>
                    <p>Solve $y'+y=\epsilon\sin x$, $y(0)=1$ to $O(\epsilon)$.</p>
                    <p>Let $y=y_{0}+\epsilon y_{1}+\cdots$. The $O(1)$ equation $y_{0}'+y_{0}=0$ gives $y_{0}=e^{-x}$. At $O(\epsilon)$, $y_{1}'+y_{1}=\sin x$ with $y_{1}(0)=0$ yields</p>
                    $$y_{1}(x)=\frac{1}{2}(\sin x-\cos x+e^{-x}).$$
                    <p>Thus $y\approx e^{-x}+\frac{\epsilon}{2}(\sin x-\cos x+e^{-x})$, matching the Taylor expansion of the exact solution.</p>
                    <p>Regular perturbation works beautifully when the perturbation is truly small and the unperturbed solution is stable. However, this success is deceptive—the series may diverge even when the exact solution is perfectly well-behaved.</p>
                </div>

                <div class="example">
                    <p><strong>Divergence in Regular Perturbation</strong></p>
                    <p>For $y'=-y+\epsilon y^{2}$, $y(0)=1$, find the perturbation series.</p>
                    <p>Solutions satisfy $y_{n}(x)=3^{-n}(n+1)^{-1}e^{-(n+1)x}$. The series</p>
                    $$y(x;\epsilon)\sim \sum_{n=0}^{\infty}\frac{\epsilon^{n}}{3^{n}(n+1)}e^{-(n+1)x}$$
                    <p>has radius $\vert \epsilon \vert <3$, yet the exact solution $y=e^{-x}/[1-\frac{\epsilon}{3}(1-e^{-x})]$ is singular at $\epsilon=3/(1-e^{-x})$. The nearest pole in the complex $\epsilon$-plane controls convergence, illustrating asymptotic (non-convergent) behavior.</p>
                    <p>The radius of convergence is controlled by the nearest singularity in the complex $\epsilon$-plane. Even when the exact solution exists for all time, the perturbation series may diverge, revealing that convergence is a delicate property.</p>
                </div>

                <div class="cliffhanger">
                    Regular perturbation works for finite time, but secular terms—unbounded corrections that grow with time—destroy validity as $t \to \infty$. The method fails precisely when we need it most: for long-time behavior and stability analysis.
                </div>

            </section>

            <section>
                <h2>Singular Perturbations and Boundary Layers</h2>

                <div class="definition">
                    <p><strong>Singular Perturbation:</strong> When $\epsilon$ multiplies the highest derivative, e.g.</p>
                    $$\epsilon y''+a(x)y'+b(x)y=0,\qquad y(0)=A,\ y(1)=B,$$
                    <p>setting $\epsilon=0$ reduces the order and loses boundary conditions. The solution adjusts rapidly inside a boundary layer of thickness $\delta(\epsilon)$ near the affected boundary. Matched asymptotic expansions build an outer series (solving the reduced equation) and an inner series using a stretched coordinate $\tau=(x-x_{0})/\epsilon^{\alpha}$. Matching their overlap determines integration constants and produces a uniformly valid composite approximation.</p>
                </div>

                <div class="example">
                    <p><strong>Linear Boundary Layer</strong></p>
                    <p>Solve $\epsilon y''+2y'+y=0$ with $y(0)=0$, $y(1)=1$.</p>
                    <p>The outer solution $y_{0}=C e^{-x/2}$ fails to satisfy both boundaries. Introducing $\tau=(1-x)/\epsilon$, the inner equation becomes $Y''-2Y'=0$ with $Y=A+B e^{2\tau}$. Matching and applying $y(1)=1$ yield the composite approximation</p>
                    $$y(x;\epsilon)\approx e^{-x/2}+(1-e^{-1/2})e^{-2(1-x)/\epsilon},$$
                    <p>capturing the boundary layer near $x=1$.</p>
                    <p>Boundary layers arise when the highest derivative is small but cannot be ignored near boundaries. The solution transitions rapidly in a thin region to satisfy the boundary condition that would otherwise be lost in the reduced equation.</p>
                </div>

                <!-- CRISIS WIDGET: Boundary Layer Formation -->
                <div class="widget-module crisis-widget widget-continuous" id="boundary-layer-1-6">
                    <div class="module-header">
                        <h3>Interactive: Watch Uniform Convergence Fail — Boundary Layer Formation</h3>
                        <div class="widget-controls">
                            <div class="widget-control">
                                <label>Small parameter $\epsilon$</label>
                                <input type="range" class="widget-slider" data-param="epsilon" min="0.01" max="0.2"
                                    step="0.01" value="0.05">
                                <span class="widget-value" data-param="epsilon">0.05</span>
                            </div>
                        </div>
                        <button class="run-button widget-run">Run</button>
                    </div>
                    <div class="plotly-container widget-output"></div>
                    <div class="code-block hidden">
                        <pre><code class="language-python">import numpy as np

# Parameters from widgets (injected automatically)
# epsilon_val will be injected here by widget engine

# Singular perturbation: ε y'' + 2y' + y = 0, y(0) = 0, y(1) = 1
# Outer solution: y_outer = C e^{-x/2}
# Boundary layer at x = 1 with thickness ~ ε
# Composite: y ≈ y_outer + (y_inner - y_outer_match) e^{-2(1-x)/ε}

x = np.linspace(0, 1, 1000)

# Outer solution (valid away from boundary layer)
# From boundary condition y(1) = 1: C e^{-1/2} = 1, so C = e^{1/2}
y_outer = np.exp(0.5 - x/2)

# Inner solution (boundary layer near x = 1)
# Stretched coordinate: τ = (1 - x) / ε
# Inner equation: Y'' - 2Y' = 0
# Solution: Y(τ) = A + B e^{2τ}
# Boundary: Y(0) = y(1) = 1, so A + B = 1
# Matching: Y(∞) = y_outer(1) = e^{-1/2}
# So A = e^{-1/2}, B = 1 - e^{-1/2}
tau = (1 - x) / epsilon_val
y_inner = np.exp(-0.5) + (1 - np.exp(-0.5)) * np.exp(2 * tau)

# Composite solution (uniformly valid)
# y_composite = y_outer + (y_inner - y_outer_match) * exp(-2(1-x)/ε)
# The matching term ensures smooth transition
y_composite = y_outer + (y_inner - np.exp(-0.5)) * np.exp(-2 * (1 - x) / epsilon_val)

# Exact solution (for comparison)
# Characteristic equation: ε r² + 2r + 1 = 0
# r = (-2 ± √(4 - 4ε)) / (2ε) = (-1 ± √(1 - ε)) / ε
r1 = float((-1 - np.sqrt(1 - epsilon_val)) / epsilon_val)
r2 = float((-1 + np.sqrt(1 - epsilon_val)) / epsilon_val)
# Solve: y(0) = C₁ + C₂ = 0, y(1) = C₁ e^{r₁} + C₂ e^{r₂} = 1
# C₁ = -C₂, so C₂ (e^{r₂} - e^{r₁}) = 1
denom = float(np.exp(r2) - np.exp(r1))
C2 = 1.0 / denom if abs(denom) > 1e-10 else 0.0
C1 = -C2
y_exact = C1 * np.exp(r1 * x) + C2 * np.exp(r2 * x)

# Boundary layer thickness
delta = 3 * epsilon_val
x_layer_start = 1 - delta

traces = []

# LEFT PLOT: Outer, inner, composite, exact
traces.append({
    'x': x.tolist(),
    'y': y_outer.tolist(),
    'mode': 'lines',
    'name': 'Outer: y = e^{1/2 - x/2}',
    'line': {'color': '#8b949e', 'width': 2, 'dash': 'dash'},
    'xaxis': 'x',
    'yaxis': 'y'
})

traces.append({
    'x': x.tolist(),
    'y': y_inner.tolist(),
    'mode': 'lines',
    'name': 'Inner (boundary layer)',
    'line': {'color': '#ffa500', 'width': 2, 'dash': 'dot'},
    'xaxis': 'x',
    'yaxis': 'y'
})

traces.append({
    'x': x.tolist(),
    'y': y_composite.tolist(),
    'mode': 'lines',
    'name': 'Composite (matched)',
    'line': {'color': '#4caf50', 'width': 3},
    'xaxis': 'x',
    'yaxis': 'y'
})

traces.append({
    'x': x.tolist(),
    'y': y_exact.tolist(),
    'mode': 'lines',
    'name': 'Exact solution',
    'line': {'color': '#ff6b6b', 'width': 2, 'dash': 'dot'},
    'xaxis': 'x',
    'yaxis': 'y'
})

# Mark boundary layer region
traces.append({
    'x': [x_layer_start, x_layer_start, 1.0, 1.0, x_layer_start],
    'y': [0.0, 1.2, 1.2, 0.0, 0.0],
    'mode': 'lines',
    'name': f'Boundary layer (δ ~ {epsilon_val:.3f})',
    'line': {'color': '#f44336', 'width': 1, 'dash': 'dash'},
    'fill': 'toself',
    'fillcolor': 'rgba(244, 67, 54, 0.15)',
    'xaxis': 'x',
    'yaxis': 'y',
    'showlegend': True
})

# Mark boundary
traces.append({
    'x': [1.0],
    'y': [1.0],
    'mode': 'markers',
    'name': 'Boundary: y(1) = 1',
    'marker': {'color': '#f44336', 'size': 12, 'symbol': 'square'},
    'xaxis': 'x',
    'yaxis': 'y'
})

# RIGHT PLOT: Error (composite - exact) and derivative
error = np.abs(y_composite - y_exact)
max_error = float(np.max(error))

# Compute derivative to show rapid transition
dy_dx = np.gradient(y_composite, x)
dy_dx_exact = np.gradient(y_exact, x)
dy_dx_error = np.abs(dy_dx - dy_dx_exact)
max_deriv_error = float(np.max(dy_dx_error))

traces.append({
    'x': x.tolist(),
    'y': error.tolist(),
    'mode': 'lines',
    'name': f'|Composite - Exact| (max = {max_error:.4f})',
    'line': {'color': '#ff6b6b', 'width': 3},
    'xaxis': 'x2',
    'yaxis': 'y2'
})

traces.append({
    'x': x.tolist(),
    'y': dy_dx_error.tolist(),
    'mode': 'lines',
    'name': f'|dy/dx error| (max = {max_deriv_error:.4f})',
    'line': {'color': '#ffa500', 'width': 2, 'dash': 'dot'},
    'xaxis': 'x2',
    'yaxis': 'y2'
})

layout = {
    'title': f'Boundary Layer: ε y\'\' + 2y\' + y = 0, ε = {epsilon_val:.3f} | δ(ε) ~ {epsilon_val:.3f}',
    'height': 600,
    'showlegend': True,
    'xaxis': {
        'title': 'x',
        'domain': [0, 0.48],
        'range': [0, 1]
    },
    'yaxis': {
        'title': 'y(x)',
        'domain': [0.52, 1],
        'range': [-0.1, 1.2]
    },
    'xaxis2': {
        'title': 'x',
        'domain': [0.52, 1],
        'range': [0, 1],
        'anchor': 'y2'
    },
    'yaxis2': {
        'title': '|Error|',
        'domain': [0.52, 1],
        'anchor': 'x2'
    },
    'annotations': [
        {
            'text': f'Boundary layer: rapid transition in region [1-3ε, 1] = [{x_layer_start:.3f}, 1.0]. Uniform convergence fails.',
            'x': 0.5,
            'y': 1.02,
            'xref': 'paper',
            'yref': 'paper',
            'showarrow': False,
            'font': {'size': 12, 'color': '#8b949e'}
        }
    ]
}

create_plot(traces, layout)</code></pre>
                    </div>
                </div>

                <div class="example">
                    <p><strong>Nonlinear Boundary Layer</strong></p>
                    <p>Solve $\epsilon y''=y^{2}-1$, $y(0)=0$, $y(1)=2$.</p>
                    <p>The outer solution is $y_{0}=1$. Near $x=0$, $\tau=x/\sqrt{\epsilon}$ leads to $Y''=Y^{2}-1$ with heteroclinic solution $Y(\tau)=\tanh(\tau/\sqrt{2})$. Matching with $y_{0}$ produces the composite $y\approx \tanh(x/\sqrt{2\epsilon})$, which coincides with the exact solution.</p>
                    <p>Nonlinear boundary layers can be solved exactly in some cases, providing exact solutions that exhibit the characteristic rapid transition. The boundary layer thickness $\delta(\epsilon) = \sqrt{\epsilon}$ reflects the nonlinear structure of the equation.</p>
                </div>

            </section>

            <section>
                <h2>Poincaré–Lindstedt Method</h2>

                <div class="theorem">
                    <p><strong>Poincaré–Lindstedt Method:</strong> For weakly nonlinear oscillators, naïve perturbation introduces resonant forcing that generates secular terms (e.g., $t\sin t$). The method rescales time by $\tau=\omega t$, expanding $\omega=1+\epsilon\omega_{1}+\epsilon^{2}\omega_{2}+\cdots$ and $y(\tau)=\sum \epsilon^{n}y_{n}(\tau)$. Choosing $\omega_{n}$ to cancel resonant terms at each order yields uniformly periodic approximations and exposes frequency shifts induced by nonlinearity.</p>
                </div>

                <div class="example">
                    <p><strong>Duffing Oscillator via Poincaré–Lindstedt</strong></p>
                    <p>Solve $y''+y+\epsilon y^{3}=0$, $y(0)=1$, $y'(0)=0$.</p>
                    <p>With $\tau=\omega t$, $\omega=1+\epsilon\omega_{1}+\epsilon^{2}\omega_{2}+\cdots$, and $y=\cos\tau+\epsilon y_{1}+\cdots$, the $O(\epsilon)$ equation produces resonance unless $\omega_{1}=3/8$. At $O(\epsilon^{2})$, eliminating resonance gives $\omega_{2}=-21/256$. Thus</p>
                    $$\omega=1+\frac{3}{8}\epsilon-\frac{21}{256}\epsilon^{2}+O(\epsilon^{3}),$$
                    <p>ensuring bounded periodic motion without secular growth.</p>
                    <p>The Poincaré–Lindstedt method reveals that nonlinearity shifts the frequency—the oscillator is no longer exactly periodic at the linear frequency. This frequency shift is a fundamental characteristic of nonlinear oscillators, observable in many physical systems.</p>
                </div>

                <!-- VICTORY WIDGET: Poincaré-Lindstedt -->
                <div class="widget-module victory-widget widget-continuous" id="poincare-lindstedt-1-6">
                    <div class="module-header">
                        <h3>Interactive: Poincaré–Lindstedt — Removing Secular Terms</h3>
                        <div class="widget-controls">
                            <div class="widget-control">
                                <label>Time $t$</label>
                                <input type="range" class="widget-slider" data-param="t" min="0" max="20" step="0.5"
                                    value="10">
                                <span class="widget-value" data-param="t">10.0</span>
                            </div>
                            <div class="widget-control">
                                <label>Perturbation $\epsilon$</label>
                                <input type="range" class="widget-slider" data-param="epsilon" min="0.1" max="0.5"
                                    step="0.05" value="0.2">
                                <span class="widget-value" data-param="epsilon">0.20</span>
                            </div>
                        </div>
                        <button class="run-button widget-run">Run</button>
                    </div>
                    <div class="plotly-container widget-output"></div>
                    <div class="code-block hidden">
                        <pre><code class="language-python">import numpy as np

# Parameters from widgets (injected automatically)
# t_val will be injected here by widget engine
# epsilon_val will be injected here by widget engine

# Duffing oscillator: y'' + y + ε y³ = 0, y(0) = 1, y'(0) = 0
# Poincaré-Lindstedt: τ = ω t, where ω = 1 + ε ω₁ + ε² ω₂ + ...
# ω₁ = 3/8, ω₂ = -21/256

# Compute frequency shift
omega1 = 3/8
omega2 = -21/256
omega = 1 + epsilon_val * omega1 + epsilon_val**2 * omega2

# Time array
t = np.linspace(0, t_val, 2000)
tau = omega * t

# Naïve perturbation (with secular terms)
# y_naive = cos(t) + ε y₁(t) + ...
# y₁ satisfies: y₁'' + y₁ = -cos³(t) = -(3/4)cos(t) - (1/4)cos(3t)
# Particular solution: y₁ = -(3/8)t sin(t) + (1/32)cos(3t)
# The secular term -(3/8)t sin(t) grows unbounded!
y_naive = np.cos(t) + epsilon_val * (-(3/8) * t * np.sin(t) + (1/32) * np.cos(3*t))

# Poincaré-Lindstedt solution (no secular terms)
# y_PL = cos(τ) + ε y₁(τ) + ...
# With frequency shift, secular terms are removed
# Leading order: y_PL ≈ cos(ω t)
y_PL = np.cos(omega * t)

# Add first correction (simplified, no secular terms)
# The correction is bounded and periodic
y_PL_corrected = np.cos(omega * t) + epsilon_val * (1/32) * np.cos(3 * omega * t)

# Exact solution (numerical, for comparison)
# We'll use a simplified approximation: y ≈ cos(ω t) for small ε
# The exact solution is periodic with frequency ω
y_exact_approx = np.cos(omega * t)

traces = []

# LEFT PLOT: Solutions over time
traces.append({
    'x': t.tolist(),
    'y': y_naive.tolist(),
    'mode': 'lines',
    'name': 'Naïve perturbation (secular terms)',
    'line': {'color': '#ff6b6b', 'width': 2, 'dash': 'dot'},
    'xaxis': 'x',
    'yaxis': 'y'
})

traces.append({
    'x': t.tolist(),
    'y': y_PL_corrected.tolist(),
    'mode': 'lines',
    'name': f'Poincaré-Lindstedt (ω = {omega:.4f})',
    'line': {'color': '#4caf50', 'width': 3},
    'xaxis': 'x',
    'yaxis': 'y'
})

traces.append({
    'x': t.tolist(),
    'y': y_exact_approx.tolist(),
    'mode': 'lines',
    'name': 'Exact (periodic)',
    'line': {'color': '#8b949e', 'width': 2, 'dash': 'dash'},
    'xaxis': 'x',
    'yaxis': 'y'
})

# RIGHT PLOT: Error (naïve - PL)
error_naive = np.abs(y_naive - y_exact_approx)
error_PL = np.abs(y_PL_corrected - y_exact_approx)

traces.append({
    'x': t.tolist(),
    'y': error_naive.tolist(),
    'mode': 'lines',
    'name': '|Naïve - Exact| (grows!)',
    'line': {'color': '#ff6b6b', 'width': 3},
    'xaxis': 'x2',
    'yaxis': 'y2'
})

traces.append({
    'x': t.tolist(),
    'y': error_PL.tolist(),
    'mode': 'lines',
    'name': '|PL - Exact| (bounded)',
    'line': {'color': '#4caf50', 'width': 2, 'dash': 'dot'},
    'xaxis': 'x2',
    'yaxis': 'y2'
})

layout = {
    'title': f'Poincaré-Lindstedt: y\'\' + y + {epsilon_val:.2f} y³ = 0 | ω = {omega:.4f} (shifted from 1)',
    'height': 550,
    'showlegend': True,
    'xaxis': {
        'title': 't',
        'domain': [0, 0.48],
        'range': [0, t_val]
    },
    'yaxis': {
        'title': 'y(t)',
        'domain': [0, 1],
        'range': [-2, 2]
    },
    'xaxis2': {
        'title': 't',
        'domain': [0.52, 1],
        'range': [0, t_val],
        'anchor': 'y2'
    },
    'yaxis2': {
        'title': '|Error|',
        'domain': [0, 1],
        'anchor': 'x2'
    },
    'annotations': [
        {
            'text': f'Frequency shift: Δω = {omega - 1:.4f}. Secular terms removed, solution remains bounded.',
            'x': 0.5,
            'y': 1.02,
            'xref': 'paper',
            'yref': 'paper',
            'showarrow': False,
            'font': {'size': 12, 'color': '#8b949e'}
        }
    ]
}

create_plot(traces, layout)</code></pre>
                    </div>
                </div>

            </section>

            <section>
                <h2>Method of Multiple Scales</h2>

                <div class="theorem">
                    <p><strong>Multiple Scales:</strong> Systems with slow modulation require independent times $t_{0}=t$, $t_{1}=\epsilon t$, etc., with $y(t;\epsilon)=Y(t_{0},t_{1},\dots;\epsilon)$. The derivative transforms as $d/dt=\partial_{t_{0}}+\epsilon\partial_{t_{1}}+\cdots$. At $O(1)$, $Y_{0}$ depends on $t_{1}$ only parametrically. The $O(\epsilon)$ equation introduces terms resonant with the homogeneous solution; enforcing solvability (orthogonality to the adjoint nullspace) yields amplitude equations governing slow evolution.</p>
                </div>

                <div class="example">
                    <p><strong>Multiple Scales for a Damped Nonlinear Oscillator</strong></p>
                    <p>Solve $y''+y+\epsilon y^{3}+\epsilon y'=0$.</p>
                    <p>Introduce $t_{0}=t$, $t_{1}=\epsilon t$, and expand $y=Y_{0}(t_{0},t_{1})+\epsilon Y_{1}+\cdots$. The $O(1)$ solution is $Y_{0}=A(t_{1})e^{i t_{0}}+\bar{A}(t_{1})e^{-i t_{0}}$. The $O(\epsilon)$ equation yields the solvability condition</p>
                    $$2A'(t_{1})+(4\vert A \vert^{2}+1)A=0,$$
                    <p>showing slow amplitude decay due to damping and nonlinearity. This envelope equation captures modulation absent from naïve perturbation.</p>
                    <p>Multiple scales reveal that the amplitude and phase evolve on a slow timescale, separate from the rapid oscillations. The solvability condition (removing resonant terms) produces evolution equations for these slow variables, capturing phenomena like amplitude decay and frequency modulation that single-scale perturbation cannot see.</p>
                </div>

                <div class="cliffhanger">
                    Multiple scales capture slow modulation, but they require ad hoc assumptions about time scales. The renormalization group method, introduced in the next section, removes these assumptions by requiring that physical results be independent of arbitrary renormalization scales.
                </div>

            </section>

            <!-- MASTERY CHALLENGES -->
            <section class="challenges">
                <h2>Mastery Challenges</h2>

                <details>
                    <summary>Challenge 1 [★★☆] Secular Term Removal</summary>
                    <p>For $y'' + y + \epsilon y^2 = 0$ with $y(0) = 1$, $y'(0) = 0$, show that naïve perturbation produces secular terms. Use Poincaré–Lindstedt to remove them and compute the frequency shift to $O(\epsilon^2)$.</p>
                    <details>
                        <summary>Solution</summary>
                        <p>Naïve perturbation gives $y_0 = \cos t$ and $y_1'' + y_1 = -\cos^2 t = -(1/2)(1 + \cos(2t))$. The particular solution includes a secular term $-(1/2)t \sin t$. Poincaré–Lindstedt with $\tau = \omega t$ and $\omega = 1 + \epsilon \omega_1 + \epsilon^2 \omega_2$ removes secular terms by choosing $\omega_1 = 0$ and $\omega_2 = -1/8$. The frequency shift is $\Delta \omega = -\epsilon^2/8 + O(\epsilon^3)$, showing that quadratic nonlinearity shifts frequency only at second order.</p>
                    </details>
                </details>

                <details>
                    <summary>Challenge 2 [★★★] Boundary Layer Matching</summary>
                    <p>For $\epsilon y'' + (1+x) y' + y = 0$ with $y(0) = 0$, $y(1) = 1$, construct the matched asymptotic expansion. Determine the boundary layer location, thickness, and the composite solution.</p>
                    <details>
                        <summary>Solution</summary>
                        <p>The outer solution satisfies $(1+x) y' + y = 0$, giving $y_{outer} = C/(1+x)$. The boundary condition $y(1) = 1$ gives $C = 2$, so $y_{outer} = 2/(1+x)$. This fails at $x = 0$ (gives $y(0) = 2 \neq 0$), so the boundary layer is at $x = 0$. The stretched coordinate is $\tau = x/\epsilon$. The inner equation is $Y'' + Y' = 0$ with $Y(0) = 0$ and matching condition $Y(\infty) = y_{outer}(0) = 2$. The solution is $Y(\tau) = 2(1 - e^{-\tau})$. The composite is $y \approx 2/(1+x) - 2 e^{-x/\epsilon}$, which satisfies both boundary conditions and matches in the overlap region.</p>
                    </details>
                </details>

                <details>
                    <summary>Challenge 3 [★★★] Multiple Scales for Van der Pol Oscillator</summary>
                    <p>Apply multiple scales to the Van der Pol oscillator $y'' - \epsilon(1-y^2) y' + y = 0$. Derive the amplitude equation and show that the limit cycle amplitude is $A = 2$.</p>
                    <details>
                        <summary>Solution</summary>
                        <p>With $t_0 = t$, $t_1 = \epsilon t$, and $y = Y_0(t_0, t_1) + \epsilon Y_1 + \cdots$, the $O(1)$ solution is $Y_0 = A(t_1) e^{i t_0} + \bar{A}(t_1) e^{-i t_0}$. The $O(\epsilon)$ equation produces secular terms unless the solvability condition is satisfied: $2A' + (1 - |A|^2/4) A = 0$. Writing $A = R e^{i\phi}$ gives $R' = (R/2)(1 - R^2/4)$ and $\phi' = 0$. The fixed point $R = 2$ is stable, giving the limit cycle amplitude $A = 2$. This demonstrates how multiple scales capture slow amplitude evolution that naïve perturbation misses.</p>
                    </details>
                </details>

            </section>

            <!-- FINAL CLIFFHANGER -->
            <div class="cliffhanger final">
                <p>We have mastered regular and singular perturbation, Poincaré–Lindstedt, and multiple scales. These methods work, but they require ad hoc assumptions: which time scales to introduce, where to place boundary layers, how to match asymptotic expansions. The renormalization group method, introduced in the next section, removes these assumptions by requiring that physical results be independent of arbitrary renormalization scales. But this elegance comes at a price: the perturbation series itself diverges, forcing us to confront Borel summation, instantons, and the need for non-perturbative methods that capture physics invisible to any power series.</p>
            </div>

            <!-- REFERENCES -->
            <section class="references">
                <h2>Key References</h2>
                <ul>
                    <li>Bender, C. M. & Orszag, S. A. (1999). <em>Advanced Mathematical Methods for Scientists and Engineers</em>.</li>
                    <li>Nayfeh, A. H. (2008). <em>Perturbation Methods</em>.</li>
                    <li>Hinch, E. J. (1991). <em>Perturbation Methods</em>.</li>
                    <li>Kevorkian, J. & Cole, J. D. (1996). <em>Multiple Scale and Singular Perturbation Methods</em>.</li>
                </ul>
            </section>

            <!-- NAVIGATION -->
            <nav class="navigation">
                <hr>
                <ul>
                    <li>Previous → <a href="/diffequations/chapter-01/01-5-asymptotic-analysis/">Section 1.5: Asymptotic Analysis</a></li>
                    <li>Next → <a href="/diffequations/chapter-01/01-7-renormalization/">Section 1.7: Classical Renormalization & Non-Perturbative Methods</a></li>
                    <li><a href="/diffequations/chapter-01/">Chapter 1 Contents</a></li>
                    <li><a href="/diffequations/">Full Table of Contents</a></li>
                </ul>
            </nav>

        </article>
    </main>

    <!-- Python/Plotly Widget System - Load after content -->
    <script>
        // Lazy load Plotly.js after page is fully loaded
        window.addEventListener('load', function () {
            var plotlyScript = document.createElement('script');
            plotlyScript.src = 'https://cdn.plot.ly/plotly-2.27.0.min.js';
            plotlyScript.charset = 'utf-8';
            plotlyScript.async = true;
            plotlyScript.onload = function () {
                console.log('Plotly.js loaded successfully');
            };
            plotlyScript.onerror = function () {
                console.error('Failed to load Plotly.js');
            };
            document.body.appendChild(plotlyScript);
        });
    </script>

    <!-- Widget Engine Scripts - Load with defer to not block rendering -->
    <script defer src="/diffequations/js/textbook-engine.js"></script>
    <script defer src="/diffequations/js/widget-engine.js"></script>
</body>

</html>
