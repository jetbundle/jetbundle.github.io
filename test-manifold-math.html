<!DOCTYPE html>
<html>
<head>
    <title>Manifold Math Diagnostic</title>
    <style>
        body { font-family: monospace; background: #0b0e17; color: #f1f5f9; padding: 20px; }
        .diagnostic { margin: 10px 0; padding: 10px; background: #111827; border-left: 3px solid #ff6b35; }
        .error { border-left-color: #ff0000; }
        .success { border-left-color: #00ff00; }
        canvas { border: 1px solid #ff6b35; margin: 20px 0; }
    </style>
</head>
<body>
    <h1>Manifold Background Math Diagnostic</h1>
    <div id="diagnostics"></div>
    <canvas id="test-canvas" width="800" height="600"></canvas>
    
    <script>
        const CONFIG = {
            centerOffsetX: -100,
            centerOffsetY: -5,
            fibersPerPoint: 24,
            maxFiberLength: 3000,
            fiberStepSize: 2.0,
            baseOpacity: 0.5,
            noiseScale: 0.008,
            noiseSpeed: 0.0001,
            animationSpeed: 0.001
        };
        
        const diagnostics = [];
        
        function log(msg, type = 'info') {
            diagnostics.push({msg, type});
            console.log(msg);
        }
        
        // Test 1: Coordinate system
        log('=== TEST 1: Coordinate System ===');
        log(`Base point: (${CONFIG.centerOffsetX}, ${CONFIG.centerOffsetY})`);
        log(`Screen viewport: (0, 0) to (800, 600)`);
        log(`Distance to screen: ${Math.sqrt(CONFIG.centerOffsetX**2 + CONFIG.centerOffsetY**2).toFixed(2)}px`);
        
        // Test 2: Angle calculation
        log('=== TEST 2: Angle Calculation ===');
        const angleSpread = Math.PI * 1.5; // 270 degrees
        const angleOffset = -Math.PI * 0.25; // -45 degrees
        log(`Angle spread: ${(angleSpread * 180 / Math.PI).toFixed(1)}째`);
        log(`Angle offset: ${(angleOffset * 180 / Math.PI).toFixed(1)}째`);
        
        const angles = [];
        for (let i = 0; i < CONFIG.fibersPerPoint; i++) {
            const angle = (angleSpread * i) / CONFIG.fibersPerPoint + angleOffset;
            angles.push(angle);
            const deg = (angle * 180 / Math.PI).toFixed(1);
            
            // Calculate where fiber would go
            const testX = CONFIG.centerOffsetX + Math.cos(angle) * 200;
            const testY = CONFIG.centerOffsetY + Math.sin(angle) * 200;
            const entersScreen = testX >= 0 && testY >= 0;
            
            log(`Fiber ${i}: angle=${deg}째, test point at (${testX.toFixed(1)}, ${testY.toFixed(1)}), enters screen: ${entersScreen}`, 
                entersScreen ? 'success' : 'error');
        }
        
        // Count how many enter screen
        let enterCount = 0;
        for (let i = 0; i < angles.length; i++) {
            const testX = CONFIG.centerOffsetX + Math.cos(angles[i]) * 200;
            const testY = CONFIG.centerOffsetY + Math.sin(angles[i]) * 200;
            if (testX >= 0 && testY >= 0) enterCount++;
        }
        log(`Fibers entering screen: ${enterCount}/${CONFIG.fibersPerPoint}`, enterCount > CONFIG.fibersPerPoint / 2 ? 'success' : 'error');
        
        // Test 3: Fiber generation math
        log('=== TEST 3: Fiber Generation ===');
        const basePoint = {x: CONFIG.centerOffsetX, y: CONFIG.centerOffsetY};
        const testAngle = Math.PI / 4; // 45 degrees (should go down-right)
        log(`Test fiber: angle=${(testAngle * 180 / Math.PI).toFixed(1)}째`);
        
        let x = basePoint.x;
        let y = basePoint.y;
        const steps = [];
        for (let i = 0; i < 100; i++) {
            x += Math.cos(testAngle) * CONFIG.fiberStepSize;
            y += Math.sin(testAngle) * CONFIG.fiberStepSize;
            steps.push({x, y});
            if (x >= 0 && y >= 0) {
                log(`Fiber enters screen at step ${i}, point (${x.toFixed(1)}, ${y.toFixed(1)})`, 'success');
                break;
            }
        }
        
        // Test 4: Opacity calculation
        log('=== TEST 4: Opacity ===');
        log(`Base opacity: ${CONFIG.baseOpacity}`);
        log(`After 100 steps (decay 0.992): ${(CONFIG.baseOpacity * Math.pow(0.992, 100)).toFixed(4)}`);
        log(`After 500 steps: ${(CONFIG.baseOpacity * Math.pow(0.992, 500)).toFixed(4)}`);
        
        // Test 5: Visual test on canvas
        log('=== TEST 5: Canvas Visual Test ===');
        const canvas = document.getElementById('test-canvas');
        const ctx = canvas.getContext('2d');
        
        // Draw viewport
        ctx.strokeStyle = 'rgba(255, 107, 53, 0.5)';
        ctx.strokeRect(0, 0, 800, 600);
        ctx.fillStyle = 'rgba(255, 107, 53, 0.1)';
        ctx.fillRect(0, 0, 800, 600);
        
        // Draw base point
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(CONFIG.centerOffsetX - 5, CONFIG.centerOffsetY - 5, 10, 10);
        ctx.fillText('Base Point', CONFIG.centerOffsetX + 10, CONFIG.centerOffsetY);
        
        // Draw test fibers
        ctx.strokeStyle = 'rgba(14, 165, 233, 0.5)';
        ctx.lineWidth = 1;
        for (let i = 0; i < angles.length; i++) {
            ctx.beginPath();
            ctx.moveTo(basePoint.x, basePoint.y);
            
            x = basePoint.x;
            y = basePoint.y;
            for (let step = 0; step < 500; step++) {
                x += Math.cos(angles[i]) * CONFIG.fiberStepSize;
                y += Math.sin(angles[i]) * CONFIG.fiberStepSize;
                ctx.lineTo(x, y);
                
                // Stop if off canvas
                if (x < -1000 || x > 2000 || y < -1000 || y > 2000) break;
            }
            ctx.stroke();
        }
        
        // Render diagnostics
        const div = document.getElementById('diagnostics');
        diagnostics.forEach(d => {
            const el = document.createElement('div');
            el.className = `diagnostic ${d.type}`;
            el.textContent = d.msg;
            div.appendChild(el);
        });
        
        log('=== DIAGNOSTIC COMPLETE ===');
    </script>
</body>
</html>

